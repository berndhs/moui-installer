#!/bin/bash

# Configuration variables
INSTALL_DIR=/tmp/sysimage
LOGFILE=/tmp/install.log
ROOTMNT=$INSTALL_DIR/rtmnt
PART_BACKUP=  #backup partition table for rollback
PART_PREFIX=
HOMEID=
ROOTID=

SYSTEM_TYPE="MeeGo"
SYSTEM_LABEL="meego"
LIVE_USER="meego"

MAIN_FS_TYPE="ext3"
BOOT_FS_TYPE="ext3"

INSTALATEUR_VERSION="0.1.4.7"

VERSION=""
IMAGE_TYPE=""
USER_ANSWER=1
SILENT_MODE=
HAS_FACTORYPART=0
FACTORYPART=
BOOTDEV=""
ROOTDEV=""
SWAPDEV=""
DEV=""
DEV_SIZE=
SMALLEST_SPACE=3000  #in MB


# For partitioning, specially for install in free space
WHOLE_DISK=
declare -a DISK_ARRAY  #without /dev/ prefix, such as sda, sdb and etc.
declare -a DISK_MENU
declare -a PART_TABLE

# For OS probe
NEED_OS_PROBE=0
OS_PROBE_ROOT_MOUNT=/tmp/os_probe_root
OS_PROBE_BOOT_MOUNT=/tmp/os_probe_boot
declare -a OTHER_PART_ARRAY
declare -a ROOT_ARRAY
declare -a BOOT_ARRAY
declare -a KERNEL_ARRAY
declare -a INITRD_ARRAY

# File systems
FORMATBOOT="mke2fs -t ${BOOT_FS_TYPE}"
FORMATROOT="mkfs.${MAIN_FS_TYPE}"
ROOT_FORMAT_OPT="-j"
FORMATSWAP="mkswap"

# Acts just like echo cmd, with automatic redirection
dbglg () {
  echo "+ `date +%T` $@" >> $LOGFILE
}

dbglg_exec () {
  echo "+ `date +%T` $@" >> $LOGFILE
  eval $@ >> $LOGFILE 2>&1
}

output () {
  echo -e "==> $@"
  dbglg $@
}

fail_exit () {
  output "\033[1;32m$@\033[0m Please check $LOGFILE for more details."
  clean_env
  exit 1
}

pre_partition () {
  partprobe /dev/$DEV >> $LOGFILE 2>&1 && sleep 1
}

post_partition () {
  if [ $? -ne 0 ]; then
    fail_exit "Partitioning failed."
  fi
  sleep 2 && partprobe /dev/$DEV >> $LOGFILE 2>&1
}

persistent_umount () {
  local MAX_TRY=10
  local i=0
  output "try to unmount " $1
  while mount |grep "$1 " > /dev/null 2>&1; do
    if [ $i -ge $MAX_TRY ]; then
      break
    fi
    dbglg_exec "umount $1"
    i=$(($i+1))
    sleep $i
  done
  if [ $i -ge $MAX_TRY ]; then
    fail_exit "Umount \"$1\" failed."
  fi
}

# returns OK if $1 contains $2
strstr() {
  [ "${1#*$2*}" = "$1" ] && return 1
  return 0
}

umount_and_rm () {
  local MOUNT_POINT=$1
  if [ -d $MOUNT_POINT ]; then
    persistent_umount $MOUNT_POINT
    dbglg_exec "rm -rf $MOUNT_POINT"
  fi
}

clean_env () {
  dbglg "clean env"
  if [ -f $PART_BACKUP ]; then
    dbglg_exec "rm -rf $PART_BACKUP"
  fi
  umount_and_rm $OS_PROBE_ROOT_MOUNT
  umount_and_rm $OS_PROBE_BOOT_MOUNT
  umount_and_rm $INSTALL_DIR/bootfs
  umount_and_rm $ROOTMNT
  dbglg_exec "rm -rf $INSTALL_DIR"
}

run_fsck () {
  if [ $IMAGE_TYPE = "liveimg" ]; then
    if [ -x $(which fsck) ]; then
      if [ X$PART_SPLIT == "Xdual" ]; then
        persistent_umount $BOOTDEV
        dbglg_exec "fsck -y $BOOTDEV"
      fi
    fi
  fi
}

check_and_choose_disk () {
  output "Check all disks and choose one to install"
  local SIZE VENDOR MODEL DISKNAME LIVE_DEV INDEX i
# Get available disks
  LIVE_DEV=""
  INDEX=0
  LIVE_DEV=`cat /etc/mtab | grep " /mnt/live " | cut -d " " -f1 | sed "s/[0-9]//"`
  for i in `cat /proc/partitions | sed -n "s/\ *[0-9][0-9]*\ *[0-9][0-9]*\ *[0-9][0-9]*\ \(\([a-z]*\)\|mmcblk[0-9]\)$/\1/p"`; do
    if test "/dev/$i" = "$LIVE_DEV" ; then
      dbglg "$i looks to be the live device, skip"
      continue
    fi
    SIZE=`sfdisk -s /dev/$i | sed 's/\([0-9]*\)[0-9]\{3\}/\1/'`
    if [ -n $SIZE -a $SIZE -ge $SMALLEST_SPACE ]; then
      VENDOR=`[ -f /sys/block/$i/device/vendor ] && cat /sys/block/$i/device/vendor`
      MODEL=`[ -f /sys/block/$i/device/model ] && cat /sys/block/$i/device/model`
      DISK_MENU[$INDEX]=$(printf "%s %s %s %s" "/dev/$i" "$VENDOR" "$MODEL" "${SIZE}MB")
      DISK_ARRAY[$INDEX]=$i
      INDEX=$(($INDEX+1))
    fi
  done
  if [ ${#DISK_ARRAY[*]} -eq 0 ]; then
    fail_exit "No disk large enough, at leat ${SMALLEST_SPACE}MB, to install $SYSTEM_TYPE."
  fi
  dbglg "Find disks: ${DISK_ARRAY[@]}, NOTE: Disks won't be listed here if its capacity is smaller than ${SMALLEST_SPACE}MB"
  dbglg "Got disk_list: ${DISK_MENU[@]}"
}

choose_device () {
# Select a disk to install $SYSTEM_TYPE
  local OLD_PS3
  OLD_PS3=$PS3
  PS3="Please select one disk to install $SYSTEM_TYPE:"
  select tmp_dev in "${DISK_MENU[@]}" "CANCEL"; do
    if [ $REPLY -eq $((1+${#DISK_ARRAY[@]})) ]; then
      fail_exit "Canceled."
    elif [ $REPLY -lt 1 -o $REPLY -gt ${#DISK_ARRAY[*]} ]; then
      echo "$PS3"
      continue
    fi
    DEV=${DISK_ARRAY[$(($REPLY-1))]}
    DEV_SIZE=$(($(sfdisk -s /dev/$DEV)/1024))  
    if [ ! -b /dev/$DEV ]; then
      output "/dev/$DEV is not a block device, please choose another one"
      continue
    fi
    break
  done
  PS3=$OLD_PS3
  unset tmp_dev
  output "Select disk /dev/$DEV ${DEV_SIZE}MB for install"
}


choose_old_or_new ()
{
  USE_EXISTING="none"
  local CHOICE_OLD CHOICE_NEW OLD_PS3
  CHOICE_NEW="use Free Space"
  CHOICE_OLD="use Existing Partition"
  OLD_PS3=$PS3
  PS3="which partition? "
  select ans in "$CHOICE_NEW" "$CHOICE_OLD" ; do
    if [ $REPLY -eq 2  ]; then
      USE_EXISTING="existing"
    elif [ $REPLY -eq 1 ]; then
      USE_EXISTING="new"
    fi
    break
  done
  PS3=$OLD_PS3
}

whole_disk () {
  local OLD_PS3
# Whether use the whole disk or not
  OLD_PS3=$PS3
  PS3="Please Choose:"
  select tmp_whole_disk in "Install $SYSTEM_TYPE In Free Space On /dev/$DEV" \
    "Remove All Partitions On /dev/$DEV And Install $SYSTEM_TYPE" "Cancel"; do
    if [ $REPLY -eq 3 ]; then
      fail_exit "Canceled."
    elif [ $REPLY -lt 1 -o $REPLY -gt 2 ]; then
      echo "$PS3"
      continue
    fi
    WHOLE_DISK=$(($REPLY-1))
    break
  done
  unset tmp_whole_disk
}

rollback () {
  local ANSWER
  echo -n "This is the last chance to rollback, Are you sure you want to continue?(y/n)[y]"
  read ANSWER
  ANSWER=$(echo $ANSWER |tr 'A-Z' 'a-z')
  if [ "x$ANSWER" = "x" -o "x$ANSWER" = "xy" ]; then
    output "Make partition table permanently"
  else
    output "Rollback disk partition table, please wait..."
    pre_partition
    sfdisk /dev/$DEV >/dev/null 2>&1 < $PART_BACKUP
    post_partition
    fail_exit "Rollback partition finished."
  fi  
}

check_partition () {
  local FACTORYPART_START FACTORYPART_SIZE
  if [[ "$DEV" == mmcblk[0-9] ]]; then
    PART_PREFIX=p;
  fi
  FACTORYPART=/dev/${DEV}${PART_PREFIX}2
  if [ -e $FACTORYPART ]; then
    dbglg "Check factorypart: $FACTORYPART"
    FACTORYPART_START=$(sfdisk -l -uM /dev/$DEV |grep "^$FACTORYPART" |awk '{printf "%d", $2}')
    FACTORYPART_SIZE=$(sfdisk -l -uM /dev/$DEV |grep "^$FACTORYPART" |awk '{printf "%d", $4}')
    dbglg "factorypart_start: $FACTORYPART_START MB factorypart_size: $FACTORYPART_SIZE MB"
    if [ $FACTORYPART_START -lt 10 -a $FACTORYPART_SIZE -le 50 ]; then
#got reserved partition, delete other partitions
      HAS_FACTORYPART=1
      for tmp_num in $(fdisk -l /dev/$DEV |grep "^/dev/" |awk '{print $1}' |rev |cut -c1);
      do
        if [ $tmp_num -eq 2 ]; then
          continue
        else
          dbglg "Remove partition /dev/${DEV}${PART_PREFIX}${tmp_num}"
          pre_partition
          fdisk /dev/$DEV >/dev/null 2>&1 <<-EOF
          d
          $tmp_num
          w
	EOF
          post_partition
        fi
      done
      sleep 1
    fi
  fi
}

use_existing_partition () {
  local ROW OLD_PS3
  OLD_PS3=$PS3
  PS3="single or split partition? "
  select ans in "single file system mounted on /" \
         "dual file systems mounted on / and /boot/" \
         "CANCEL"; do
    if [ $REPLY -eq 1  ]; then
      PART_SPLIT="single"
      break
    elif [ $REPLY -eq 2 ]; then
      PART_SPLIT="dual"
      break
    elif [ $REPLY -eq 3 ]; then
      PART_SPLIT="quit"
      break
    fi
  done
  PS3=$OLD_PS3
# Special case for mmc-devices, add a p before the partition number
  if [[ "$DEV" == mmcblk[0-9] ]]; then
    PART_PREFIX="p"
  else
    PART_PREFIX=""
  fi
  if [ X$PART_SPLIT == "Xdual" ] ; then
    use_existing_dual_partition
  elif [ X$PART_SPLIT == "Xsingle" ]; then
    use_existing_single_partition
  else
    fail_exit "User Cancelled"
  fi
}

use_existing_single_partition () {

# make sure partition has the right type
  local PART PART_LINE PART_DEV PART_TYPE ROW
  local PART_START PART_END PART_SIZE
# Umount device if it is mounted
  for i in $(mount |grep "$DEV" |awk '{print $1}'); do
    output "Umount $i, please wait..."
    persistent_umount $i
  done
# Backup partition table before partitioning
  PART_BACKUP="/tmp/sfdisk.$DEV.backup.$$"
  sfdisk -d /dev/$DEV > $PART_BACKUP

  sfdisk -l -uM /dev/$DEV

# Use user selected partiton
  output "Install $SYSTEM_TYPE in single partition"
  echo -n " which partition [1] ?"
  read PART
  output " You chose partition " $PART
  INDEX=1    
  LEN_PART=$(expr length $PART)
  if [ $LEN_PART -ne 1 ]; then
    fail_exit "bad partition number " $PART_NUM
  fi
  INDEX=1
  ROW=1
  FOUND=0
  PART_SIZE=0
  for PART_LINE in $(
                   sfdisk -l -uM /dev/sda | 
                   grep '^/dev/' | 
                   sed 's/\*/\ /' | 
                   awk '{printf "%s,%d,%d,%s ", $1,$2,$3,$6}'
                   )
    do
    output "looking at " $PART_LINE
    PART_DEV=$(echo $PART_LINE | cut -d',' -f1)
    PART_START=$(echo $PART_LINE | cut -d',' -f2)
    PART_END=$(echo $PART_LINE | cut -d',' -f3)
    PART_TYPE=$(echo $PART_LIEN | cut -d',' -f4)
    if [ $ROW -eq $PART ]; then
      PART_SIZE=$(($PART_END-$PART_START+1))
      FOUND=1
      break
    fi
    ROW=$(($ROW+1))
  done

# check if big enough
  INDEX=1
  output "Find " $FOUND " space ${PART_SIZE}MB at [$PART_START,$PART_END]MB"
# Free space is large enough?
  if [ $PART_SIZE -lt $SMALLEST_SPACE ]; then
    fail_exit " Not enough space, at least ${SMALLEST_SPACE}MB, please partitioning yourself."
  fi
  SWAPDEV=$(sfdisk -l /dev/$DEV |
                  grep "^/dev/.*Linux swap / Solaris$" |
                  awk '{print $1}' |
                  head -1
                )
  if [ X$SWAPDEV == "X" ]; then
    fail_exit "No Swap partition found"
  fi
  if [ ! X$PART_TYPE == "X83" ]; then
    change_partition_type $DEV $PART "83"
  fi
  ROOTDEV="/dev/${DEV}${PART_PREFIX}${PART}"
}

change_partition_type () {
  local THE_DEV PART_NUM THE_TYPE
  THE_DEV=$1
  PART_NUM=$2
  THE_TYPE=$3
  fdisk /dev/$DEV >> $LOGFILE 2>&1 <<EOF
t
$PART_NUM
$THE_TYPE
w
EOF

# toggle the old boot partition to not be bootable
  old_bootdev=$(sfdisk -l /dev/$DEV 2>/dev/null |grep "^/dev/" |grep "\*" |awk '{print $1}' |grep -o "[1-9]\|[1-9][0-9]")
  if [ -n $old_bootdev ]; then
    output " partitioning stage 20"
    output " de-bootify " $old_bootdev " of /dev/"$DEV 
    pre_partition
    sfdisk -N$old_bootdev /dev/$DEV --force >> $LOGFILE 2>&1 <<EOF
,,,-
y
EOF
    post_partition
    output " partitioning stage 21"
  fi
# toggle the new boot partition to be bootable
  new_bootdev=$PART_NUM
  output " partitioning stage 23"
  output " bootify " $new_bootdev " of /dev/"$DEV 
  pre_partition
  sfdisk -N$new_bootdev /dev/$DEV --force >> $LOGFILE 2>&1 <<EOF
,,,*
y
EOF
  post_partition
  output " partitioning stage 22"

  fdisk -l /dev/$DEV
}

use_existing_dual_partition () {
  local DISK_USED DISK_FREE HOLE_START HOLE_END HOLE_SIZE INDEX i
  local HAS_EXTENDED EXTENDED_START EXTENDED_END EXTENDED_NR
  local BOOT_SIZE SWAP_SIZE ROOT_SIZE
  local LOGICAL_CUR_MAX LOGICAL_BOOT
  local PART LEN_PART FOUND
  WHOLE_DISK=0
# Umount device firstly if it mounted.
  for i in $(mount |grep "$DEV" |awk '{print $1}'); do
    output "Umount $i, please wait..."
    persistent_umount $i
  done
# Backup partition table before partitioning
  PART_BACKUP="/tmp/sfdisk.$DEV.backup.$$"
  sfdisk -d /dev/$DEV > $PART_BACKUP
  BOOT_SIZE=200
  SWAP_SIZE=256
# Get partition table
  INDEX=1    
  for i in $(sfdisk -l -uM /dev/$DEV |grep "^/dev/" |grep -v "Extended" |grep -v "Empty" |
    awk '{if(NF<=8){printf "%d,%d\n", $((NF-5)),$((NF-4))}else{printf "%d,%d\n", $((NF-8)),$((NF-7))}}' |sort -n); do
    tmp_s=$(echo $i |cut -d',' -f1)
    tmp_e=$(echo $i |cut -d',' -f2)
# Has no extended partition
    PART_TABLE[$INDEX]=$tmp_s
    PART_TABLE[$(($INDEX+1))]=$tmp_e
    INDEX=$(($INDEX+2))
  done

  sfdisk -l -uM /dev/$DEV

# Use user selected partiton
  output "Install $SYSTEM_TYPE in partition"
  echo -n " which partition [1] ?"
  read PART
  output " You chose partition " $PART
  INDEX=1    
  LEN_PART=$(expr length $PART)
  if [ $LEN_PART -ne 1 ]; then
    fail_exit "bad partition number " $PART_NUM
  fi
  INDEX=1
  ROW=1
  HOLE_SIZE=0
  FOUND=0
  for i in $(sfdisk -l -uM /dev/$DEV |
               grep "^/dev/" |
               grep -v "Extended" |
               grep -v "Empty" |
    awk '{if(NF<=8){printf "%d,%d\n", $((NF-5)),$((NF-4))}else{printf "%d,%d\n", $((NF-8)),$((NF-7))}}' |sort -n); do
    tmp_s=$(echo $i |cut -d',' -f1)
    tmp_e=$(echo $i |cut -d',' -f2)
# Has no extended partition
    PART_TABLE[$INDEX]=$tmp_s
    PART_TABLE[$(($INDEX+1))]=$tmp_e
    INDEX=$(($INDEX+2))
    HOLE_START=${tmp_s}
    HOLE_END=${tmp_e}
    HOLE_SIZE=$((${HOLE_END} - ${HOLE_START}))
    output " Part " $ROW " start " $HOLE_START " end " $HOLE_END " size " $HOLE_SIZE
    if [ $ROW -eq $PART ]; then
      FOUND=1
      break;
    fi
    ROW=$(($ROW+1))
  done
  unset tmp_s tmp_e
# Find the max free space hole
  INDEX=1
  output "Find " $FOUND " space ${HOLE_SIZE}MB at [$HOLE_START,$HOLE_END]MB"
# Free space is large enough?
  if [ $HOLE_SIZE -lt $SMALLEST_SPACE ]; then
    fail_exit "Can't find suitable free space, at least ${SMALLEST_SPACE}MB, please partitioning yourself."
  fi
  LOGICAL_BOOT=5
  output "Create default partition layout, please wait..."
# If has no extended partition, creat one
  EXTENDED_NR=$(sfdisk -l /dev/$DEV |grep "^/dev/" |grep "Empty" |head -1 |awk '{print $1}' |rev |cut -c1)
  output "extended " $EXTENDED_NR
  if [ -z $EXTENDED_NR ]; then
    EXTENDED_NR=$PART
  else
    if [ $EXTENDED_NR -ne $PART ]; then
      fail_exit "Already have extended partition, cannot create another"
    fi
  fi
  output " Partition " $PART " size " $HOLE_SIZE 
  output " will convert to extended " $EXTENDED_NR
  output " on device /dev/"$DEV
  output " partitioning stage 1"
  pre_partition
  sfdisk /dev/$DEV -N$EXTENDED_NR --force >> $LOGFILE 2>&1 <<EOF
    ,,E,
y
EOF
  post_partition
  output " partitioning stage 2"
# If there is a swap partition, just use it
  tmp_swap_nr=$(sfdisk -l /dev/$DEV |
               grep "^/dev/.*Linux swap / Solaris$" |
               awk '{print $1}' |
               grep -o "[1-9]\|[1-9][0-9]" |
               head -1)
  ROOT_SIZE=$(($HOLE_MAX-$BOOT_SIZE-$SWAP_SIZE))
  pre_partition
  if [ $IMAGE_TYPE = "liveimg" ]; then
    if [ -z $tmp_swap_nr ]; then
      output " partitioning stage 3"
      fdisk /dev/$DEV >> $LOGFILE 2>&1 <<-EOF
      n
      l
	+${BOOT_SIZE}M
      n
      l

	+${ROOT_SIZE}M
      n
      l


      w
	EOF
    else
      output " partitioning stage 4"
      output "Find swap partition on this disk, just use it"
      fdisk /dev/$DEV >> $LOGFILE 2>&1 <<-EOF
      n
      
        +${BOOT_SIZE}M
      n
      

      w
	EOF
    fi
  elif [ $IMAGE_TYPE = "nandfs" ]; then
    if [ -z $tmp_swap_nr ]; then
      output " partitioning stage 5"
      fdisk /dev/$DEV >> $LOGFILE 2>&1 <<EOF
n
l
+${ROOT_SIZE}M
n
l

w
EOF
    else
      output "Find swap partition on this disk, just use it"
      output " partitioning stage 6"
      fdisk /dev/$DEV >> $LOGFILE 2>&1 <<EOF
n
l

w
EOF
    fi
  fi
  post_partition
  output " partitioning stage 7"
# Special case for mmc-devices, add a p before the partition number
  if [[ "$DEV" == mmcblk[0-9] ]]; then
    PART_PREFIX=p;
  fi
  if [ $WHOLE_DISK -eq 1 ]; then
    if [ $IMAGE_TYPE = "liveimg" ]; then
      BOOTDEV=/dev/${DEV}${PART_PREFIX}1
      ROOTDEV=/dev/${DEV}${PART_PREFIX}2
      SWAPDEV=/dev/${DEV}${PART_PREFIX}3
    elif [ $IMAGE_TYPE = "nandfs" ]; then
      ROOTDEV=/dev/${DEV}${PART_PREFIX}1
      if [ $HAS_FACTORYPART -eq 0 ]; then
        SWAPDEV=/dev/${DEV}${PART_PREFIX}2
      elif [ $HAS_FACTORYPART -eq 1 ]; then
        SWAPDEV=/dev/${DEV}${PART_PREFIX}3
      fi
    fi
  elif [ $WHOLE_DISK -eq 0 ]; then
    if [ $IMAGE_TYPE = "liveimg" ]; then
      BOOTDEV=/dev/${DEV}${PART_PREFIX}$LOGICAL_BOOT
    fi
# toggle the old boot partition to not be bootable
    old_bootdev=$(sfdisk -l /dev/$DEV 2>/dev/null |grep "^/dev/" |grep "\*" |awk '{print $1}' |grep -o "[1-9]\|[1-9][0-9]")
    if [ -n $old_bootdev ]; then
      output " partitioning stage 8"
      output " de-bootify " $old_bootdev " of /dev/"$DEV 
      pre_partition
      sfdisk -N$old_bootdev /dev/$DEV --force >> $LOGFILE 2>&1 <<EOF
,,,-
y
EOF
      post_partition
      output " partitioning stage 8.5"
    fi
    unset old_bootdev
# toggle the new boot partition bootable
    output " partitioning stage 9"
    output " logical boot is now " $LOGICAL_BOOT
    pre_partition
    sfdisk -N$LOGICAL_BOOT /dev/$DEV --force >> $LOGFILE 2>&1 <<EOF
,,,*
y
EOF
    post_partition
    if [ $IMAGE_TYPE = "liveimg" ]; then
      ROOTDEV=/dev/${DEV}${PART_PREFIX}$(($LOGICAL_BOOT+1))
    elif [ $IMAGE_TYPE = "nandfs" ]; then
      ROOTDEV=/dev/${DEV}${PART_PREFIX}$LOGICAL_BOOT
    fi
    if [ -z $tmp_swap_nr ]; then
      if [ $IMAGE_TYPE = "liveimg" ]; then
        SWAPDEV=/dev/${DEV}${PART_PREFIX}$(($LOGICAL_BOOT+2))
      elif [ $IMAGE_TYPE = "nandfs" ]; then
        SWAPDEV=/dev/${DEV}${PART_PREFIX}$(($LOGICAL_BOOT+1))
      fi
      pre_partition
      if [ $IMAGE_TYPE = "liveimg" ]; then
        sfdisk -c /dev/$DEV $(($LOGICAL_BOOT+2)) 82
      elif [ $IMAGE_TYPE = "nandfs" ]; then
        sfdisk -c /dev/$DEV $(($LOGICAL_BOOT+1)) 82
      fi
      post_partition
    else
      SWAPDEV=/dev/${DEV}${PART_PREFIX}$tmp_swap_nr
    fi
  else
    fail_exit "Never should be here. 2"
  fi
  unset tmp_swap_nr
  output "Partitioning finished"
# the last chance to roll back
  output "====================new partition table======================"
  if [ $HAS_FACTORYPART -eq 0 ]; then
    sfdisk -l -uM /dev/$DEV |tee -a $LOGFILE
  else
    sfdisk -l /dev/$DEV |tee -a $LOGFILE
  fi
  output "============The following partitions will be used============"
  tmp_awk_str="%-15s%-15s%-15s%-10s\n"
  echo -e "Device\tMount Point\tFilesystem\tSize(MB)" |awk -F'\t' '{printf "'$tmp_awk_str'", $1,$2,$3,$4}' |tee -a $LOGFILE
  if [ $IMAGE_TYPE = "liveimg" ]; then
    echo -e "${BOOTDEV}\t/boot\text3\t${BOOT_SIZE}" |awk -F'\t' '{printf "'$tmp_awk_str'", $1,$2,$3,$4}' |tee -a $LOGFILE
  fi  
  echo -e "${ROOTDEV}\t/\t${MAIN_FS_TYPE}\t${ROOT_SIZE}" |awk -F'\t' '{printf "'$tmp_awk_str'", $1,$2,$3,$4}' |tee -a $LOGFILE
  echo -e "${SWAPDEV}\t\tswap\t${SWAP_SIZE}" |awk -F'\t' '{printf "'$tmp_awk_str'", $1,$2,$3,$4}' |tee -a $LOGFILE
  unset tmp_awk_str
  if [ $SILENT_MODE -eq 0 ]; then
    rollback
  fi

}



create_partitions () {
  local DISK_USED DISK_FREE HOLE_START HOLE_END HOLE_MAX INDEX i
  local HAS_EXTENDED EXTENDED_START EXTENDED_END EXTENDED_NR
  local BOOT_SIZE SWAP_SIZE ROOT_SIZE
  local LOGICAL_CUR_MAX LOGICAL_BOOT
  if [ $SILENT_MODE -eq 0 ]; then
    whole_disk
  elif [ $SILENT_MODE -eq 1 ]; then
    WHOLE_DISK=1
  else
    fail_exit "Never should be here. 3"
  fi
# Umount device firstly if it mounted.
  for i in $(mount |grep "$DEV" |awk '{print $1}'); do
    output "Umount $i, please wait..."
    persistent_umount $i
  done
# Backup partition table before partitioning
  PART_BACKUP="/tmp/sfdisk.$DEV.backup.$$"
  sfdisk -d /dev/$DEV > $PART_BACKUP
  BOOT_SIZE=200
  SWAP_SIZE=256
# Use whole disk
  if [ $WHOLE_DISK -eq 1 ]; then
    output "Install $SYSTEM_TYPE in whole disk"
    if [ $IMAGE_TYPE = "liveimg" ]; then
      ROOT_SIZE=$((DEV_SIZE - SWAP_SIZE - BOOT_SIZE))
      dbglg "got dev_size=${DEV_SIZE}MB boot_size=${BOOT_SIZE}MB swap_size=${SWAP_SIZE}MB root_size=${ROOT_SIZE}MB"
    elif [ $IMAGE_TYPE = "nandfs" ]; then
      SWAP_SIZE=32
      ROOT_SIZE=$(($DEV_SIZE-$SWAP_SIZE))
      dbglg "got dev_size=${DEV_SIZE}MB swap_size=${SWAP_SIZE}MB root_size=${ROOT_SIZE}MB"
    fi
    output "Create default partition layout, please wait..."
    pre_partition
    if [ $IMAGE_TYPE = "liveimg" ]; then
      sfdisk -uM /dev/$DEV >> $LOGFILE 2>&1 <<-EOF
      ,$BOOT_SIZE,L,*
      ,$ROOT_SIZE,L
      ,,S
	EOF
    elif [ $IMAGE_TYPE = "nandfs" ]; then
      check_partition
      if [ $HAS_FACTORYPART -eq 0 ]; then
        sfdisk -uM /dev/$DEV >> $LOGFILE 2>&1 <<-EOF
        ,$ROOT_SIZE,L,*
        ,,S
        EOF
      elif [ $HAS_FACTORYPART -eq 1 ]; then
        output "Reserve $FACTORYPART"
        FACTORYPART_END_CYL=$(sfdisk -l /dev/$DEV |grep "^$FACTORYPART" |awk '{printf "%d", $3}')
        CYL_TOTAL=$(fdisk -l /dev/$DEV 2>/dev/null |grep "heads,.*sectors/track,.*cylinders" |awk '{print $5}')
        CYL_SIZE=$(fdisk -l /dev/$DEV 2>/dev/null |grep "^Units" |awk '{printf "%d", $9}')
        SWAP_SIZE_CYL=$(($SWAP_SIZE*1024*1024/$CYL_SIZE))
        ROOT_SIZE_CYL=$(($CYL_TOTAL-$SWAP_SIZE_CYL-$FACTORYPART_END_CYL-2))
        ROOT_SIZE=$(($ROOT_SIZE_CYL*$CYL_SIZE/1024/1024))
        dbglg "cylinders:$CYL_TOTAL, cylinder size:$CYL_SIZE, factorypart_cyl_end: $FACTORYPART_END_CYCLE"
        dbglg "root_start_cyl=$(($FACTORYPART_END_CYL+1)), root_size_cyl:$ROOT_SIZE_CYL, root_size: $ROOT_SIZE"
        dbglg "swap_start_cyl=$(($FACTORYPART_END_CYL+$ROOT_SIZE_CYL+1)), swap_size_cyl:$SWAP_SIZE_CYL, swap_size:$SWAP_SIZE"
        dbglg "sfdisk /dev/$DEV -N1"
        sfdisk /dev/$DEV -N1 >> $LOGFILE 2>&1 <<-EOF
        $(($FACTORYPART_END_CYL+1)),$ROOT_SIZE_CYL,L,*
        y
	EOF
        dbglg "sfdisk /dev/$DEV -N3"
        sfdisk /dev/$DEV -N3 >> $LOGFILE 2>&1 <<-EOF
        $(($FACTORYPART_END_CYL+$ROOT_SIZE_CYL+1)),$SWAP_SIZE_CYL,S
        y
	EOF
      fi
    fi
    post_partition
# Use free space, it's a little complicated
  elif [ $WHOLE_DISK -eq 0 ]; then
    output "Install $SYSTEM_TYPE in free space"
# Has an extended partition or not, if so, we just lookup free space in extended partition
    if sfdisk -l /dev/$DEV |grep "Extended" >/dev/null 2>&1; then
      HAS_EXTENDED=1
      EXTENDED_START=$(sfdisk -l -uM /dev/$DEV |grep "^/dev/" |grep "Extended" |awk '{printf "%d", $2}')
      EXTENDED_END=$(sfdisk -l -uM /dev/$DEV |grep "^/dev/" |grep "Extended" |awk '{printf "%d", $3}')
      PART_TABLE[0]=$EXTENDED_START
    else
      if ! sfdisk -l /dev/$DEV |grep "^/dev/" |grep "Empty" > /dev/null 2>&1; then
        fail_exit "Can't create extended partition, there are already 4 primary partitions."
      fi
      HAS_EXTENDED=0
      PART_TABLE[0]=0
    fi
# Whether free space large enough or not
    DISK_USED=$(sfdisk -l -uM /dev/$DEV |grep "^/dev/" |grep -v "Extended" |grep -v "Empty" |awk 'BEGIN{sum=0}{sum+=$((NF-3))}END{print sum}')
    DISK_FREE=$(($DEV_SIZE-$DISK_USED))
    if [ $DISK_FREE -lt $SMALLEST_SPACE ]; then
      fail_exit "Free space is too small, at least need ${SMALLEST_SPACE}MB, there is only ${DISK_FREE}MB left."
    fi
# Get partition table
    INDEX=1    
    for i in $(sfdisk -l -uM /dev/$DEV |grep "^/dev/" |grep -v "Extended" |grep -v "Empty" |
      awk '{if(NF<=8){printf "%d,%d\n", $((NF-5)),$((NF-4))}else{printf "%d,%d\n", $((NF-8)),$((NF-7))}}' |sort -n); do
      tmp_s=$(echo $i |cut -d',' -f1)
      tmp_e=$(echo $i |cut -d',' -f2)
# Has no extended partition
      if [ $HAS_EXTENDED -eq 0 ]; then
        PART_TABLE[$INDEX]=$tmp_s
        PART_TABLE[$(($INDEX+1))]=$tmp_e
        INDEX=$(($INDEX+2))
# Has extended partition
      elif [ $HAS_EXTENDED -eq 1 ]; then
        if [ $tmp_s -ge $EXTENDED_START -a $tmp_e -le $EXTENDED_END ]; then
          PART_TABLE[$INDEX]=$tmp_s
          PART_TABLE[$(($INDEX+1))]=$tmp_e
          INDEX=$(($INDEX+2))
        fi
      else
        fail_exit "Never should be here. 4"
      fi
    done
    unset tmp_s tmp_e
    if [ $HAS_EXTENDED -eq 0 ]; then
      PART_TABLE[$INDEX]=$DEV_SIZE
    elif [ $HAS_EXTENDED -eq 1 ]; then
      PART_TABLE[$INDEX]=$EXTENDED_END
    else
      fail_exit "Never should be here. 5"
    fi
    dbglg "partition table: ${PART_TABLE[@]}"
# Find the max free space hole
    INDEX=1
    HOLE_MAX=0
    while [ $INDEX -lt ${#PART_TABLE[*]} ]; do
      tmp_hole=$((${PART_TABLE[$(($INDEX))]}-${PART_TABLE[$(($INDEX-1))]}))
      if [ $tmp_hole -gt $HOLE_MAX ]; then
        HOLE_MAX=$tmp_hole
        HOLE_START=${PART_TABLE[$(($INDEX-1))]}
        HOLE_END=${PART_TABLE[$INDEX]}
      fi
      INDEX=$(($INDEX+2))
    done
    unset tmp_hole
    output "Find free space ${HOLE_MAX}MB at [$HOLE_START,$HOLE_END]MB"
# Free space is large enough?
    if [ $HOLE_MAX -lt $SMALLEST_SPACE ]; then
      fail_exit "Can't find suitable free space, at least ${SMALLEST_SPACE}MB, please partitioning yourself."
    fi
    LOGICAL_BOOT=5
    output "Create default partition layout, please wait..."
# If has no extended partition, creat one
    if [ $HAS_EXTENDED -eq 0 ]; then
      EXTENDED_NR=$(sfdisk -l /dev/$DEV |grep "^/dev/" |grep "Empty" |head -1 |awk '{print $1}' |rev |cut -c1)
      if [ -z $EXTENDED_NR ]; then
        fail_exit "Never should be here. 6"
      fi
      pre_partition
      sfdisk -uM /dev/$DEV -N$EXTENDED_NR >> $LOGFILE 2>&1 <<-EOF
      $(($HOLE_START+1)),$(($HOLE_MAX-10)),E,
      y
	EOF
      post_partition
# If has extended partition
    elif [ $HAS_EXTENDED -eq 1 ]; then
      LOGICAL_CUR_MAX=$(sfdisk -l /dev/$DEV |grep "^/dev/" |awk '{print $1}' |grep -o "[1-9]\|[1-9][0-9]" |sort -nr |head -1)
      if [ $LOGICAL_CUR_MAX -ge $LOGICAL_BOOT ]; then
        LOGICAL_BOOT=$(($LOGICAL_CUR_MAX+1))
      fi
    else
      fail_exit "Never should be here. 7"
    fi
# If there is a swap partition, just use it
    tmp_swap_nr=$(sfdisk -l /dev/$DEV |grep "^/dev/.*Linux swap / Solaris$" |awk '{print $1}' |grep -o "[1-9]\|[1-9][0-9]" |head -1)
    ROOT_SIZE=$(($HOLE_MAX-$BOOT_SIZE-$SWAP_SIZE))
    pre_partition
    if [ $IMAGE_TYPE = "liveimg" ]; then
      if [ -z $tmp_swap_nr ]; then
        fdisk /dev/$DEV >> $LOGFILE 2>&1 <<-EOF
        n
        l

        +${BOOT_SIZE}M
        n
        l

        +${ROOT_SIZE}M
        n
        l


        w
	EOF
      else
        output "Find swap partition on this disk, just use it"
        fdisk /dev/$DEV >> $LOGFILE 2>&1 <<-EOF
        n
        l

        +${BOOT_SIZE}M
        n
        l


        w
	EOF
      fi
    elif [ $IMAGE_TYPE = "nandfs" ]; then
      if [ -z $tmp_swap_nr ]; then
        fdisk /dev/$DEV >> $LOGFILE 2>&1 <<-EOF
        n
        l

        +${ROOT_SIZE}M
        n
        l


        w
	EOF
      else
        output "Find swap partition on this disk, just use it"
        fdisk /dev/$DEV >> $LOGFILE 2>&1 <<-EOF
        n
        l


        w
	EOF
      fi
    fi
    post_partition
  else
    fail_exit "Never should be here. 8"
  fi
# Special case for mmc-devices, add a p before the partition number
  if [[ "$DEV" == mmcblk[0-9] ]]; then
    PART_PREFIX=p;
  fi
  if [ $WHOLE_DISK -eq 1 ]; then
    if [ $IMAGE_TYPE = "liveimg" ]; then
      BOOTDEV=/dev/${DEV}${PART_PREFIX}1
      ROOTDEV=/dev/${DEV}${PART_PREFIX}2
      SWAPDEV=/dev/${DEV}${PART_PREFIX}3
    elif [ $IMAGE_TYPE = "nandfs" ]; then
      ROOTDEV=/dev/${DEV}${PART_PREFIX}1
      if [ $HAS_FACTORYPART -eq 0 ]; then
        SWAPDEV=/dev/${DEV}${PART_PREFIX}2
      elif [ $HAS_FACTORYPART -eq 1 ]; then
        SWAPDEV=/dev/${DEV}${PART_PREFIX}3
      fi
    fi
  elif [ $WHOLE_DISK -eq 0 ]; then
    if [ $IMAGE_TYPE = "liveimg" ]; then
      BOOTDEV=/dev/${DEV}${PART_PREFIX}$LOGICAL_BOOT
    fi
# toggle the old boot partition doesn't bootable
    pre_partition
    old_bootdev=$(sfdisk -l /dev/$DEV 2>/dev/null |grep "^/dev/" |grep "\*" |awk '{print $1}' |grep -o "[1-9]\|[1-9][0-9]")
    if [ -n $old_bootdev ]; then
      sfdisk -N$old_bootdev /dev/$DEV >> $LOGFILE 2>&1 <<-EOF
      ,,,-
	EOF
      post_partition
    fi
    unset old_bootdev
# toggle the new boot partition bootable
    pre_partition
    sfdisk -N$LOGICAL_BOOT /dev/$DEV >> $LOGFILE 2>&1 <<-EOF
    ,,,*
	EOF
    post_partition
    if [ $IMAGE_TYPE = "liveimg" ]; then
      ROOTDEV=/dev/${DEV}${PART_PREFIX}$(($LOGICAL_BOOT+1))
    elif [ $IMAGE_TYPE = "nandfs" ]; then
      ROOTDEV=/dev/${DEV}${PART_PREFIX}$LOGICAL_BOOT
    fi
    if [ -z $tmp_swap_nr ]; then
      if [ $IMAGE_TYPE = "liveimg" ]; then
        SWAPDEV=/dev/${DEV}${PART_PREFIX}$(($LOGICAL_BOOT+2))
      elif [ $IMAGE_TYPE = "nandfs" ]; then
        SWAPDEV=/dev/${DEV}${PART_PREFIX}$(($LOGICAL_BOOT+1))
      fi
      pre_partition
      if [ $IMAGE_TYPE = "liveimg" ]; then
        sfdisk -c /dev/$DEV $(($LOGICAL_BOOT+2)) 82
      elif [ $IMAGE_TYPE = "nandfs" ]; then
        sfdisk -c /dev/$DEV $(($LOGICAL_BOOT+1)) 82
      fi
      post_partition
    else
      SWAPDEV=/dev/${DEV}${PART_PREFIX}$tmp_swap_nr
    fi
  else
    fail_exit "Never should be here. 9"
  fi
  unset tmp_swap_nr
  output "Partitioning finished"
# the last chance to roll back
  output "====================new partition table======================"
  if [ $HAS_FACTORYPART -eq 0 ]; then
    sfdisk -l -uM /dev/$DEV |tee -a $LOGFILE
  else
    sfdisk -l /dev/$DEV |tee -a $LOGFILE
  fi
  output "============The following partitions will be used============"
  tmp_awk_str="%-15s%-15s%-15s%-10s\n"
  echo -e "Device\tMount Point\tFilesystem\tSize(MB)" |awk -F'\t' '{printf "'$tmp_awk_str'", $1,$2,$3,$4}' |tee -a $LOGFILE
  if [ $IMAGE_TYPE = "liveimg" ]; then
    echo -e "${BOOTDEV}\t/boot\text3\t${BOOT_SIZE}" |awk -F'\t' '{printf "'$tmp_awk_str'", $1,$2,$3,$4}' |tee -a $LOGFILE
  fi  
  echo -e "${ROOTDEV}\t/\t${MAIN_FS_TYPE}\t${ROOT_SIZE}" |awk -F'\t' '{printf "'$tmp_awk_str'", $1,$2,$3,$4}' |tee -a $LOGFILE
  echo -e "${SWAPDEV}\t\tswap\t${SWAP_SIZE}" |awk -F'\t' '{printf "'$tmp_awk_str'", $1,$2,$3,$4}' |tee -a $LOGFILE
  unset tmp_awk_str
  if [ $SILENT_MODE -eq 0 ]; then
    rollback
  fi
}

wait_proceed () {
  local Q_FOR_QUIT
  echo -n "Proceed or Q for quit [proceed] ? "
  read Q_FOR_QUIT
  if [ X$Q_FOR_QUIT == "XQ" ]; then
    fail_exit "User Quit"
  fi
  if [ X$Q_FOR_QUIT == "Xq" ]; then
    fail_exit "User quit"
  fi
}

create_fs () {
  local PART_ORG
  PART_ORG=$1
  output "Create " $PART_ORG " filesystems"
# If device is not null
  pre_partition
  output " See if we create boot device " $BOOTDEV
  BOOT_DIR=$INSTALL_DIR/boot
  if [ $IMAGE_TYPE = "liveimg" ]; then
    if [ X${PART_ORG} == "Xdual" ]; then
      BOOT_DIR=$INSTALL_DIR/bootfs
      if [ -n $BOOTDEV ]; then
        persistent_umount $BOOTDEV
        output "Creating filesystem on $BOOTDEV: ${BOOT_FS_TYPE}"
        dbglg_exec "$FORMATBOOT $BOOTDEV"
      elif [ $IMAGE_TYPE != "nandfs" ]; then  
        fail_exit "No boot device."
      fi
    else
      BOOT_DIR=$ROOTMNT/boot
    fi
  fi
  output " See if we create root device " $ROOTDEV
  if [ -n $ROOTDEV ]; then
    persistent_umount $ROOTDEV
    output "Creating filesystem on $ROOTDEV: ${MAIN_FS_TYPE}"
#workaround for the issue of creating ${MAIN_FS_TYPE}
    if cat /proc/mounts | grep "^/dev/root" >/dev/null 2>&1 && [ ! -e /dev/root ]; then
      HAS_BTRFSWORKAROUND="yes"
      dbglg_exec "touch /dev/root"
    fi
    output "want to do: " "$FORMATROOT $ROOT_FORMAT_OPT $ROOTDEV"
    dbglg_exec "$FORMATROOT $ROOT_FORMAT_OPT $ROOTDEV"
    if [ X${MAIN_FS_TYPE} == "Xbtrfs" ]; then
      if [ ! -z $HAS_BTRFSWORKAROUND ]; then
        dbglg_exec "rm -rf /dev/root"
      fi
    fi
  else
    fail_exit "No root device"  
  fi
  output " See if we create swap device " $SWAPDEV
  if [ -n $SWAPDEV ]; then
    persistent_umount $SWAPDEV
    output "Creating filesystem on $SWAPDEV: swap"
    dbglg_exec "$FORMATSWAP $SWAPDEV"
  else
    fail_exit "No swap device."
  fi
# Make root and home subvol's
  output " Main File system type is " ${MAIN_FS_TYPE}
  if [ X${MAIN_FS_TYPE} == "Xbtrfs" ]; then
    dbglg_exec "mount $ROOTDEV $ROOTMNT -o subvolid=0"
    dbglg_exec "${MAIN_FS_TYPE} subvol create $ROOTMNT/${SYSTEM_LABEL}_root"
    dbglg_exec "${MAIN_FS_TYPE} subvol create $ROOTMNT/${SYSTEM_LABEL}_home"
    ROOTID=$(${MAIN_FS_TYPE} subvol list $ROOTMNT | awk ' ($7 == "${SYSTEM_LABEL}_root") { print $2 }')
    HOMEID=$(${MAIN_FS_TYPE} subvol list $ROOTMNT | awk ' ($7 == "${SYSTEM_LABEL}_home") { print $2 }')
    dbglg_exec "${MAIN_FS_TYPE} subvol set-default $ROOTID $ROOTMNT"
    persistent_umount $ROOTMNT
  fi
# Create /home with proper permissions inside ${SYSTEM_LABEL}_root
  mkdir -p $ROOTMNT
  dbglg_exec "mount $ROOTDEV $ROOTMNT"
  dbglg_exec "chmod 0755 $ROOTMNT"
  dbglg_exec "mkdir $ROOTMNT/home"
  dbglg_exec "chmod 0755 $ROOTMNT/home"
  if [ X$PART_SPLIT == "Xdual" ]; then
    dbglg_exec "mkdir $ROOTMNT/bootfs"
    dbglg_exec "chmod 0755 $ROOTMNT/bootfs"
  else
    dbglg_exec "mkdir $ROOTMNT/boot"
    dbglg_exec "chmod 0755 $ROOTMNT/boot"
    dbglg_exec "mkdir $ROOTMNT/boot/extlinux"
    dbglg_exec "chmod 0755 $ROOTMNT/boot/extlinux"
  fi
  persistent_umount $ROOTMNT
}

progress_bar () {
  local FINISH TOTAl PRO_BAR NUM PER_CENT
  FINISH=$1
  TOTAL=$2
  PER_CENT=$3
  NUM=0
  PRO_BAR="   ["
  while [ $NUM -lt $TOTAL ]; do
    NUM=$((NUM + 1))
    if [ $NUM -le $FINISH ]; then
      PRO_BAR="${PRO_BAR}="
    else
      PRO_BAR="${PRO_BAR} "
    fi
  done
  if [ $PER_CENT -lt 10 ]; then
    PRO_BAR="${PRO_BAR}]   ${PER_CENT}%"
  else
    PRO_BAR="${PRO_BAR}]  ${PER_CENT}%"
  fi
  echo -ne "\r$PRO_BAR"
}

check_status () {
  local FS TOTAL_SIZE CUR_SIZE PER_CENT
  FS=$1
  TOTAL_SIZE=$2
  progress_bar 0 25 0
  while true; do
    sleep 5
    CUR_SIZE=`df $FS | grep "$FS" | tr -s ' ' ' ' | cut -d' ' -f3`
    PER_CENT=$((CUR_SIZE*100/TOTAL_SIZE))
    NUM=$((PER_CENT/4))
    if [ $PER_CENT -eq 100 ]; then
      dbglg "Copy programme finished? Also check with rsync process"
    fi
    CP_STATUS=`ps ax | grep  "rsync -aq.*$ROOTMNT" | grep -v grep | wc -l`
    dbglg "$FS $TOTAL_SIZE $CUR_SIZE $PER_CENT $NUM $CP_STATUS"
    if [ $CP_STATUS -lt 1 ]; then
      dbglg "Copy programme finished, set progress bar to 100%"
      progress_bar 25 25 100
      break
    fi
#the filesystem size calculation of compressed ${MAIN_FS_TYPE} is not so accurate here
    if [ $PER_CENT -gt 100 ]; then
      PER_CENT=100
    fi
    progress_bar $NUM 25 $PER_CENT
  done
}

mount_check () {
  output "mount check: " $@
  eval "$@" >> $LOGFILE 2>&1
  if [ $? -ne 0 ]; then
    output "mount table:"
    fail_exit "Failed to mount."
  fi
}

copy_fs () {

  local BOOT_EXCLUDE

  dbglg "Set timezone before copying: /usr/sbin/hwclock --hctosys -u"
  /usr/sbin/hwclock --hctosys -u >> $LOGFILE 2>&1
  output "Mount partitions"
# Attempt to mount the prepared partition using the given partition fs type
  if [ X${MAIN_FS_TYPE} == "Xbtrfs" ]; then
    dbglg "mount -t ${MAIN_FS_TYPE} -o relatime,compress $ROOTDEV $ROOTMNT"
    mount_check "mount -t ${MAIN_FS_TYPE} -o relatime,compress $ROOTDEV $ROOTMNT"
    dbglg "mount -t ${MAIN_FS_TYPE} -o relatime,compress,subvolid=$HOMEID $ROOTDEV $ROOTMNT/home"
    mount_check "mount -t ${MAIN_FS_TYPE} -o relatime,compress,subvolid=$HOMEID $ROOTDEV $ROOTMNT/home"
  else
    output "Using fstype " ${MAIN_FS_TYPE}
    output "try mount -t ${MAIN_FS_TYPE} $ROOTDEV $ROOTMNT"
    dbglg "mount -t ${MAIN_FS_TYPE} $ROOTDEV $ROOTMNT"
    mount_check "mount -t ${MAIN_FS_TYPE}  $ROOTDEV $ROOTMNT"
  fi
  if [ $IMAGE_TYPE = "liveimg" ]; then
    if [ X$PART_SPLIT == "Xdual" ]; then
      dbglg "mount -t ${BOOT_FS_TYPE} $BOOTDEV $INSTALL_DIR/bootfs"
      mount_check "mount -t ${BOOT_FS_TYPE} $BOOTDEV $INSTALL_DIR/bootfs"
    fi
  fi
# Copy OS
  output "Copy root file system"
  TOTAL_SIZE=`df /| grep /| tr -s ' ' ' ' | cut -d' ' -f3`
  dbglg "Read root fs size = $TOTAL_SIZE"
  if [ $IMAGE_TYPE = "liveimg" ]; then
    dbglg_exec "rsync -aq --exclude=/home/${LIVE_USER} --exclude=/boot/* --exclude=/dev/* --exclude=/proc/* --exclude=/sys/* --exclude=/media/* --exclude=/tmp/* / $ROOTMNT &"
  elif [ $IMAGE_TYPE = "nandfs" ]; then
    dbglg_exec "rsync -aq --exclude=/dev/* --exclude=/proc/* --exclude=/sys/* --exclude=/media/* --exclude=/tmp/* / $ROOTMNT &"
  fi
  check_status $ROOTMNT $TOTAL_SIZE
  echo ""
# Create minimal devices
  dbglg_exec "mkdir -m 0755 $ROOTMNT/dev/pts"
  dbglg_exec "mknod -m 0666 $ROOTMNT/dev/null c 1 3"
  dbglg_exec "mknod -m 0666 $ROOTMNT/dev/urandom c 1 9"
  dbglg_exec "mknod -m 0666 $ROOTMNT/dev/random c 1 8"
  dbglg_exec "mknod -m 0666 $ROOTMNT/dev/full c 1 7"
  dbglg_exec "mknod -m 0666 $ROOTMNT/dev/ptmx c 5 2"
  dbglg_exec "mknod -m 0666 $ROOTMNT/dev/zero c 1 5"
  dbglg_exec "mknod -m 0755 $ROOTMNT/dev/console c 5 1ls"
  dbglg_exec "mknod -m 0755 $ROOTMNT/dev/fb0 c 29 0"
  dbglg_exec "mknod -m 0666 $ROOTMNT/dev/tty c 4 0"
  dbglg_exec "mknod -m 0666 $ROOTMNT/dev/tty1 c 4 1"
  dbglg_exec "mknod -m 0666 $ROOTMNT/dev/tty2 c 4 2"
  dbglg_exec "ln -s /proc/self/fd $ROOTMNT/dev/fd"
  dbglg_exec "ln -s /proc/self/fd/0 $ROOTMNT/dev/stdin"
  dbglg_exec "ln -s /proc/self/fd/1 $ROOTMNT/dev/stdout"
  dbglg_exec "ln -s /proc/self/fd/2 $ROOTMNT/dev/stderr"
  if [ $IMAGE_TYPE = "liveimg" ]; then
    output "Copy boot file system to " $BOOT_DIR
    progress_bar 0 25 0
    dbglg_exec "rsync -aq /boot/ $BOOT_DIR"
    progress_bar 25 25 100
    echo ""
  fi
  if [ X$PART_SPLIT == "Xsingle" ]; then
    dbglg_exec "mkdir -m 0755 $ROOTMNT/home"
  fi
  output "Syncing filesystem, please wait..."
  dbglg_exec "sync"
}

write_fstab () {
  local FSTAB_FILE
  FSTAB_FILE=${ROOTMNT}/etc/fstab
  output "Write fstab and mtab"
  echo "# Created by instalateur " > $FSTAB_FILE
  if [ $IMAGE_TYPE = "liveimg" ]; then
    echo "$BOOTDEV    /boot   ${BOOT_FS_TYPE}    defaults                                    1 2" >> $FSTAB_FILE
  fi
  if [ X${MAIN_FS_TYPE} == "Xbtrfs" ]; then
    echo "$ROOTDEV    /       ${MAIN_FS_TYPE}   nodatasum,relatime,compress                 1 1" >> $FSTAB_FILE
    echo "$ROOTDEV    /home   ${MAIN_FS_TYPE}   nodatasum,relatime,compress,subvolid=$HOMEID    1 2" >> $FSTAB_FILE
  else 
    echo "$ROOTDEV    /       ${MAIN_FS_TYPE}   defaults                 1 1" >> $FSTAB_FILE
  fi
  echo "$SWAPDEV    swap    swap    defaults                                    0 0" >> $FSTAB_FILE

  cat >> $FSTAB_FILE <<EOF
tmpfs                   /dev/shm                tmpfs   defaults        0 0
devpts                  /dev/pts                devpts  gid=5,mode=620  0 0
sysfs                   /sys                    sysfs   defaults        0 0
proc                    /proc                   proc    defaults        0 0
EOF

  dbglg_exec "rm -rf $ROOTMNT/etc/mtab"
  dbglg "write /etc/adjtime"
  if [ ! -f ${ROOTMNT}/etc/adjtime ]; then
    echo "0.0 0 0.0" > ${ROOTMNT}/etc/adjtime
    echo "0" >> ${ROOTMNT}/etc/adjtime
  fi
  echo "UTC" >> ${ROOTMNT}/etc/adjtime
  cat ${ROOTMNT}/etc/adjtime >> $LOGFILE 2>&1
}

os_probe () {
  local ROOT_PART FSTAB OS_PREFIX INDEX i j
  output "Probe other installed operating systems"
# Find other partitions that maybe a root(/) partition
  INDEX=0
  for i in $(sfdisk -l /dev/$DEV |grep "^/dev/" |grep -v "Extended" |grep -v "Empty" |grep -v "Linux swap / Solaris" |awk '{print $1}' |
    grep -o "[1-9]\|[1-9][0-9]"); do
    if [ "/dev/${DEV}${PART_PREFIX}$i" != "$ROOTDEV" -a "/dev/${DEV}${PART_PREFIX}$i" != "$BOOTDEV" ]; then
      OTHER_PART_ARRAY[$INDEX]="/dev/${DEV}${PART_PREFIX}$i"
      INDEX=$(($INDEX+1))
    fi
  done
  dbglg "OTHER_PART_ARRAY=${OTHER_PART_ARRAY[@]}"
# Find other /boot partitions
  if [ ${#OTHER_PART_ARRAY[*]} -eq 0 ]; then
    output "No other operating system"
    return 1
  fi
  FSTAB="$OS_PROBE_ROOT_MOUNT/etc/fstab"
  INDEX=0
  for ROOT_PART in ${OTHER_PART_ARRAY[@]}; do
    if ! mount $ROOT_PART $OS_PROBE_ROOT_MOUNT >> $LOGFILE 2>&1 ; then
      dbglg "mount $ROOT_PART $OS_PROBE_ROOT_MOUNT FAILED"
      continue
    fi
# Maybe non-linux system
    if [ ! -f $FSTAB ]; then
      dbglg "$ROOT_PART is not an linux / partition"
      persistent_umount $OS_PROBE_ROOT_MOUNT
      continue
    fi
# Store in array
    ROOT_ARRAY[$INDEX]=$ROOT_PART
# Find the corresponding /boot partition
    tmp_boot=$(cat $FSTAB |grep -v "^\s*#" |grep "/boot" |awk '{print $1}')
# No seperately /boot partition
    if [ -z $tmp_boot ]; then
      BOOT_ARRAY[$INDEX]=$ROOT_PART
      INDEX=$(($INDEX+1))
      persistent_umount $OS_PROBE_ROOT_MOUNT
      continue
    elif echo "$tmp_boot" |grep "UUID=" > /dev/null 2>&1; then
      tmp_boot_uuid=${tmp_boot#*UUID=}
      tmp_boot="/dev/$(ls -l /dev/disk/by-uuid |grep $tmp_boot_uuid |rev |cut -d'/' -f1 |rev)"
    fi
    BOOT_ARRAY[$INDEX]=$tmp_boot
    INDEX=$(($INDEX+1))
    persistent_umount $OS_PROBE_ROOT_MOUNT
    unset tmp_boot tmp_boot_uuid
  done
  dbglg "find / partitions: ${ROOT_ARRAY[@]}"
  dbglg "find /boot partitions: ${BOOT_ARRAY[@]}"
# Find kernel/initrd in /boot partitions
  INDEX=0
  for i in ${BOOT_ARRAY[@]}; do
    if ! mount $i $OS_PROBE_BOOT_MOUNT >> $LOGFILE 2>&1; then
      output "Mount $ROOT_PART $OS_PROBE_BOOT_MOUNT FAILED"
      INDEX=$(($INDEX+1))
      continue
    fi
    if [ -d $OS_PROBE_BOOT_MOUNT/boot ]; then
      tmp_dir="$OS_PROBE_BOOT_MOUNT/boot"
      OS_PREFIX="/boot"
    else
      tmp_dir="$OS_PROBE_BOOT_MOUNT"
      OS_PREFIX=""
    fi
    for j in $(find $tmp_dir -type f -name "vmlinu[z|x]*"); do
      tmp_ker="${j#*$tmp_dir/}"
      tmp_ver=$(echo "$tmp_ker" |cut -d'-' -f2-)
      tmp_ker="${OS_PREFIX}/$tmp_ker"
      tmp_ker_str=$(printf "%s,%s" $tmp_ker $tmp_ker_str)
      if [ -f $tmp_dir/initrd.img-$tmp_ver ]; then
        tmp_initrd="${OS_PREFIX}/initrd.img-$tmp_ver"
        tmp_initrd_str=$(printf "%s,%s" $tmp_initrd $tmp_initrd_str)
      else
        tmp_initrd_str=$(printf "%s,%s" "no-initrd" $tmp_initrd_str)
      fi
      unset tmp_ker tmp_ver tmp_ker_str tmp_initrd tmp_initrd_str
    done
    KERNEL_ARRAY[$INDEX]="$tmp_ker_str"
    INITRD_ARRAY[$INDEX]="$tmp_initrd_str"
    output "Find kernels: $tmp_ker_str in $i"
    output "Find initrds: $tmp_initrd_str in $i"
    INDEX=$(($INDEX+1))
    persistent_umount $OS_PROBE_BOOT_MOUNT
    unset tmp_dir
  done
  return 0
}

update_extlinux () {
  local LABEL="label Linux"
  local KERNEL INITRD APPEND INDEX ROOT_PART index
  declare -a tmp_ker_array
  declare -a tmp_initrd_array
  INDEX=0
  for ROOT_PART in ${ROOT_ARRAY[@]}; do
    APPEND="${ROOT_PART} quiet vga=current"
# Get kernel array for an OS
    tmp_ker_str=${KERNEL_ARRAY[$INDEX]}
    index=0
    for tmp_ker in ${tmp_ker_str//,/ }; do
      tmp_ker_array[$index]=$tmp_ker
      index=$(($index+1))
    done
# Get initrd array for an OS
    tmp_initrd_str=${INITRD_ARRAY[$INDEX]}
    index=0
    for tmp_initrd in ${tmp_initrd_str//,/ }; do
      tmp_initrd_array[$index]=$tmp_initrd
      index=$(($index+1))
    done
# Get extlinux menu
    index=0
    for tmp_ker in ${tmp_ker_array[@]}; do
      MENU="menu label Linux (${tmp_ker##*/})"
      KERNEL="kernel $tmp_ker"
      echo "$LABEL" >> $1
      echo "        $MENU"  >> $1
      echo "        $KERNEL" >> $1
      if [ "no-initrd" != "${tmp_initrd_array[$index]}" ]; then
        INITRD="initrd ${tmp_initrd_array[$index]}"
        echo "        $INITRD" >> $1
      fi
      echo "        append ro root=$APPEND" >> $1
      index=$(($index+1))
    done
    INDEX=$((INDEX+1))
    unset tmp_ker tmp_initrd tmp_ker_str tmp_initrd_str
  done
  unset tmp_ker_array tmp_initrd_array
}

ask_mbr () {
  # return 1 if use wants to re-write MBR, 0 if not
  local OLD_PS3
  OLD_PS3=$PS3
  PS3="select boot loader option [leave]-> "
  select ans in "Install new Boot Loader" \
                "Leave old Boot Loader" 
  do
    if [ $REPLY -eq 1 ]; then
      MBR_REWRITE="new"
      break
    elif [ $REPLY -eq 2 ]; then
      MBR_REWRITE="leave"
      break
    fi
  done         
  PS3=$OLD_PS3
  if [ X$MBR_REWRITE != "Xleave" ]; then
    return 1
  else
    return 0
  fi
}

install_syslinux () {
  local CONF_FILE=$BOOT_DIR/extlinux/extlinux.conf
  local CONF_DIR=$BOOT_DIR/extlinux
  local BOOTFS_DIR=$BOOT_DIR
  local KERN LABEL i
  local BOOT_QUIET="quiet"
  local BOOT_LEVEL=""

  output "Install Boot Information"
  
  if [ ! -x /sbin/extlinux ]; then
    fail_exit "Syslinux-extlinux package is not installed."
  fi
# Install extlinux
  output "Install extlinux to " $CONF_DIR
  output "$INSTALL_DIR/bootfs has "
  ls $INSTALL_DIR/bootfs
  dbglg_exec "/sbin/extlinux -i $CONF_DIR"
  

  MBR_REWRITE="leave"
  ask_mbr
  if [ ! X$MBR_REWRITE == "Xleave" ] ; then
    output "Write MBR loader to /dev/$DEV"
    dbglg_exec "/bin/dd if=/dev/$DEV of=${CONF_DIR}/mbr.bak count=1 bs=512"
    dbglg_exec "/bin/dd if=${ROOTMNT}/usr/share/syslinux/mbr.bin of=/dev/$DEV"
  fi
# Generate extlinux.conf
  output "Install extlinux.conf in " $CONF_FILE
  echo "# extlinux.conf - generated by instalateur " | tee $CONF_FILE
  echo "" | tee -a $CONF_FILE
  echo "prompt 0" | tee -a $CONF_FILE
  echo "timeout 80" | tee -a $CONF_FILE
  for i in ivi connext automotive; do
    IVI=`find $BOOTFS_DIR -name config-*-$i`
    if [ -z $IVI ]; then
      continue
    else
      break;
    fi
  done
  dbglg "Is this IVI build? $IVI"
  if [ -z $IVI ]; then
    echo "default vesamenu.c32" | tee -a $CONF_FILE
  else
    echo "default menu.c32" | tee -a $CONF_FILE
  fi
  cat >> $CONF_FILE <<EOF

menu autoboot Starting $SYSTEM_TYPE...
menu background splash.jpg
menu title Welcome to $SYSTEM_TYPE!
menu color border      0 #ffffffff #00000000
menu color sel         7 #ffffffff #ff000000
menu color title       0 #ffffffff #00000000
menu color tabmsg      0 #ffffffff #00000000
menu color unsel       0 #ffffffff #00000000
menu color hotsel      0 #ff000000 #ffffffff
menu color hotkey      7 #ffffffff #ff000000
menu color timeout_msg 0 #ffffffff #00000000
menu color timeout     0 #ffffffff #00000000
menu color cmdline     0 #ffffffff #00000000

EOF
  KERN=`find $BOOTFS_DIR -name vmlinuz-* -printf %f`
  LABEL=${KERN/vmlinuz-/}
  dbglg "Read kern=$KERN label=$LABEL"
  echo "label ${SYSTEM_LABEL}" | tee -a $CONF_FILE
  echo "        menu label $SYSTEM_TYPE ($LABEL)" | tee -a $CONF_FILE
  echo "        kernel $KERN" | tee -a $CONF_FILE
  echo "        append ro root=$ROOTDEV $BOOT_QUIET $BOOT_LEVEL vga=current" | tee -a $CONF_FILE
  echo "        menu default" | tee -a $CONF_FILE

  CONF_FILE_LS=$(ls -l $CONF_FILE)
  output " conf file is here: " $CONF_FILE_LS
  output " conf file contains "
  cat $CONF_FILE
  output "Copy background picture"
  dbglg_exec "cp ${ROOTMNT}/usr/lib/anaconda-runtime/syslinux-vesa-splash.jpg ${CONF_DIR}/splash.jpg"
  dbglg_exec "ln -s ../${KERN} ${CONF_DIR}/${KERN}"
}

create_factory_snapshot ()
{
  # create a quick snapshot of ${SYSTEM_LABEL}_root -> ${SYSTEM_LABEL}_root_factory
  return
  sync
  persistent_umount $ROOTMNT/home
  persistent_umount $ROOTMNT
  dbglg_exec "mount -o subvolid=0 $ROOTDEV $ROOTMNT"
  dbglg_exec "${MAIN_FS_TYPE} subvol snapshot $ROOTMNT/${SYSTEM_LABEL}_root $ROOTMNT/${SYSTEM_LABEL}_root_factory"
  persistent_umount $ROOTMNT
}

rebuild_initrd () {
  output "Rebuild initrd with new fstab"
  chroot ${ROOTMNT} /bin/sh <<-'END'
  for KVER in $(ls /lib/modules); do
    INITRD="/boot/initrd-${KVER}.img"
    if [ -w $INITRD ]; then
      mkinitrd -f $INITRD $KVER >/dev/null
    fi
  done
        if [ -w /boot/kboot.cmdline ]; then
    sed -i "s/ 4 */ /" /boot/kboot.cmdline
        fi
	END
}

ask_useradd () {
  local OLD_PS3 ADDUSER
  OLD_PS3=$PS3
  PS3="add user for installed system? [yes]-> "
  ADDUSER=1
  TRIAL_COUNT=0
  select ANS in "Add User Account" \
                "Do Not Add User Account" 
  do
    if [ $REPLY -eq 1 ]; then
      ADDUSER=0
      break
    elif [ $REPLY -eq 2 ]; then
      ADDUSER=1
      break
    fi
    TRIALCOUNT=$((TRIALCOUNT+1))
    if [ $TRIALCOUNT -ge 3 ]; then
      break
    fi
  done         
  PS3=$OLD_PS3
  return $ADDUSER
}

do_useradd () {
  local NEW_USER TMPEXEC
  NEW_USER="none"
  echo ""
  read -p "User Name: " NEW_USER
  NOSPACE_USER=$(echo $NEW_USER | awk '{print $1}')
  TMPSCRIPT=/tmp/do_useradd
  TMPEXEC=${ROOTMNT}${TMPSCRIPT}
  if [ ! X$NOSPACE_USER == "X" ]; then
    echo '#/!bin/bash' > $TMPEXEC
    echo "NOSPACE_USER="$NOSPACE_USER >> $TMPEXEC
    echo 'useradd $NOSPACE_USER --password ""' \
          >> $TMPEXEC
    echo 'echo "user=$NOSPACE_USER" >> /etc/sysconfig/uxlaunch' \
          >> $TMPEXEC
    echo 'echo "AUTOLOGIN_USER=$NOSPACE_USER" >> /etc/sysconfig/desktop' \
          >> $TMPEXEC
    chmod u+x $TMPEXEC
    dbglg_exec "chroot $ROOTMNT $TMPSCRIPT"
  fi
}

do_postinstall () {
  local POST_SCRIPT="/etc/instalateur/post_install.sh"
  output "Run post install scripts"
  if [ ! -f $POST_SCRIPT ]; then
    output " no post install script"
    dbglg "The post script $POST_SCRIPT doesn't exist, return"
    return
  fi
  dbglg_exec "cp $POST_SCRIPT ${ROOTMNT}$POST_SCRIPT"
  dbglg_exec "mount -t proc proc $ROOTMNT/proc"
  dbglg_exec "mount -t devpts devpts $ROOTMNT/dev/pts"
  dbglg_exec "mount -t sysfs sysfs $ROOTMNT/sys"
  dbglg_exec "chroot $ROOTMNT $POST_SCRIPT"
  if ask_useradd ; then
    do_useradd
  fi
  persistent_umount $ROOTMNT/sys
  persistent_umount $ROOTMNT/dev/pts
  persistent_umount $ROOTMNT/proc
}

VERSION=`head -1 /etc/${SYSTEM_LABEL}-release`
trap "clean_env" INT TERM
echo > $LOGFILE
output "Welcome to $SYSTEM_TYPE $VERSION"
output " "
output "Installer version " $INSTALATEUR_VERSION
output " "
# should not be present in install mode, but in case of ...
dbglg_exec "killall -9 automountd >/dev/null 2>&1"

# Clean environent before start
clean_env
output "Start install"

# Create directory for the install partition to be mounted
mkdir -p $ROOTMNT
mkdir -p $INSTALL_DIR/bootfs
mkdir -p $OS_PROBE_ROOT_MOUNT
mkdir -p $OS_PROBE_BOOT_MOUNT

check_and_choose_disk
USER_ANSWER=0
#wait_user " !! Destroy all data on $(echo ${DISK_MENU[0]} |tr -s ' ' ' ') and install? "
if [ $USER_ANSWER -eq 0 ]; then
  SILENT_MODE=0
  choose_device
  output ""
  output "\033[1;33mWARNING:\033[0m"
  output ""
  output "You are going to install $SYSTEM_TYPE."
  output "For this /dev/$DEV will be formated"
  output "Some or all existing data on this disk will be lost."
  output ""
elif [ $USER_ANSWER -eq 1 ]; then
  SILENT_MODE=1
  if [ ! -b /dev/${DISK_ARRAY[0]} ]; then
    fail_exit "/dev/${DISK_ARRAY[0]} is not a block device."
  fi
  DEV=${DISK_ARRAY[0]}
  DEV_SIZE=$(($(sfdisk -s /dev/$DEV)/1024))  
else
  fail_exit "Never should be here. 10"
fi
#check the image type
cmdline=$(cat /proc/cmdline)
if strstr "$cmdline" liveimg || [ -e /dev/live-osimg ]; then
  IMAGE_TYPE="liveimg"
else
  IMAGE_TYPE="nandfs"
fi

USE_EXISTING="new"
choose_old_or_new

PART_SPLIT="dual"
if [ X$USE_EXISTING == "Xexisting" ]; then
  use_existing_partition
elif [ X$USE_EXIUSTING == "Xnew" ]; then
  create_partitions
else
  fail_exit "Cancelled Installation"
fi

output "Create file sytems for " $PART_SPLIT
create_fs $PART_SPLIT
output "Copy file sytems for " $PART_SPLIT
copy_fs $PART_SPLIT
output "Write fstab"
write_fstab
if [ "$IMAGE_TYPE" = "liveimg" ]; then
  output "Install syslinux..."
  install_syslinux
else
  rebuild_initrd
fi
do_postinstall

output "Copy log file"
dbglg_exec "cp $LOGFILE $ROOTMNT$LOGFILE"

create_factory_snapshot

output "Clean up a little"
clean_env

output "Run inital fsck"
run_fsck

# finish and reboot
output ""
output "Installation is complete."
output ""
output "You can shutdown the device, unplug the removable disk and boot"
output "to the installed system."
output ""
exit 0
